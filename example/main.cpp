/*                                                                                                         
 ██                           ░░                                              ░▓▒                          ▓█ 
 ███▒                        ▓███                                           ░████░                       ░███ 
 ▒████░                      ▓████▒                                        ▒█████░                      ▓███▓ 
  █████▓                     ▒█████▓                                      ███████░                    ▒█████░ 
  ███████▒                   ░██████▓                                    ███▓█▓██░                  ░███████  
  ▓██▓█████                  ░███▓▓▒▓▒                                  █████▓███░                ░████████▓  
  ░███▓█▓███▒                ▒██▓▒▒▒▒▓░                                ▒█▓███████                ▒████▓█▓██░  
   ██▓█▓█▓████               ▒█▒▒▒▒▒▒▒▒░                              ░▓▒▒▒▓▓▓███               █████▓█▓███   
   ▓██▓█▓█▓████░             ░▓▒▒▒▒▒▒▒▒▒░                             ▒▒▒▒▒▒▒▒▓█▓             ░█████▓█▓████   
   ▒███▓█▓█▓████▓            ░▒▒▒▒▒▒▒░░░▒░                           ▒▒▒▒▒▒▒▒▒▒▓▒            ▒███▓█▓█▓█▓██▓   
   ░██▓█▓█▓█▓████▓           ░▒▒░░░░░░░░░▒                          ░▒░░░░░▒▒▒▒▒            ▓█████▓█▓█▓███▒   
   ░███▓█▓█▓█▓█████           ▒░░░░░░░░░░░░                        ░▒░░░░░░░░░▒▒           ▓███▓█▓█▓█▓█▓██░   
    ████▓█▓█▓█▓█████          ▒░░░░░░░░░░░░░                      ░▒░░░░░░░░░▒▒░          ████▓█▓█▓█▓█▓███    
    ███▓█▓█▓█▓█▓█▓███         ░░░░░░░░░░░░░░                      ▒░░░░░░░░░░░▒          ████▓█▓█▓█▓█▓████    
    ▒███▓█▓█▓█▓█▓█▓███        ░▒░░░░░░░░░░░▒░                    ░▒░░░░░░░░░░░░         ████▓█▓█▓█▓█▓█▓██▓    
    ░██▓█▓█▓█▓█▓█▓████▒        ▒▒░░░░░░░░░░▒▒                    ▒▒░░░▒░▒░░░░░░        ▒███▓█▓█▓█▓█▓█▓███░    
     ███▓█▓█▓█▓█▓█▓███▓░       ░▒▒░▒▒▒▒▒▒▒░▒▒     ░░░░░░░░░     ░▒▒▒▒░░░░░░░░▒        ░▒▓█▓█▓█▓█▓█▓█▓████     
     ▒███▓█▓█▓█▓█▓█▓█▓▒▒░       ░▒▒░░░░░▒▒▒▒▒▒▓▒▓▓▓░▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒░░▒▒░▒▒▒▒▒░       ░▒░▓██▓█▓█▓█▓█▓█▓██▒     
      ████▓█▓█▓█▓█▓██▓▒▒▒         ░░░░ ░▒▒░░ ░░░░▒░ ░░ ░░░░░▒█░  ░░ ░░░░░░▒▒░        ▒▒▒▓█▓█▓█▓█▓█▓█▓███      
      ▒██▓█▓█▓█▓█▓█▓███▒▒░         ░▒▒▒▒▓▓▒  ░  ░░  ▒░▒▒▒░░░░  ░▒░░▒▒▒▒░░░░         ░▒▓████▓█▓█▓█▓█▓███▒      
       ███▓█▓█▓█▓█▓█▓███▓▓         ▒▒▒▓▓▒▒▒░░      ░▒▒▒░▒▓░ ░ ▒▓▒▒▒▓▓▓▒▒▓▒▒░        ▓█████▓█▓█▓█▓█▓████       
       ░███▓█▓█▓█▓█▓█▓█████      ▒▒░  ░    ░░▒▒▒░   ░▒▒░    ░░ ▒▒▒░ ░   ░ ░▒▒      ▓███▓█▓█▓█▓█▓█▓█▓██▒       
        ▓███▓█▓█▓█▓█▓█▓█▓██▒   ░▓▓▓▒▒░ ░▒▒   ░▓▒▒░       ░░░░        ░▒▒░▒▒▓▓█▒   ▒███▓█▓█▓█▓█▓█▓█▓███        
         ████▓█▓█▓█▓█▓█▓█▓██  ▓█████▓▒▒▒▒▓▒           ░░░     ▒▓▒▓█████████████▓  ███▓█▓█▓█▓█▓█▓█▓███         
          ████▓█▓█▓█▓█▓█▓███▓▒█████▓░░ ░░  ▓██░ ░          ░▒▓██▓██▓░░░░████████▒▒██▓█▓█▓█▓█▓█▓█████░         
           ████▓█▓█▓█▓█▓█▓█████▓███▓▒▒▓▓▒▒▓████▓██             ██▓░▒░░▒░▒▓███▓█████▓█▓█▓█▓█▓█▓█████░          
            ████▓█▓█▓█▓█▓█▓█▓██████▓███████▓▓████░           ▒  ▒▒░░ ▒▓▓▒▒████▓█████▓█▓█▓█▓█▓█████            
             ▓█████▓█▓█▓█▓█▓█▓███▓    ░▒███▓███░          ░▓███▒░░▒▓██▒░    ▓██▓█▓█▓█▓█▓█▓█▓████▓             
              ░█████▓█▓█▓█▓█▓███▓        ░█████░          ███▓██████▒        ███▓█▓█▓█▓█▓█▓████▒              
                ▓██████▓█▓█▓█▓██           ▓████      ░  ▒███▓█████           ███▓█▓█▓█▓█████▓                
                 ░██████▓█▓█▓███     ▒▓▓░   █████     ░░  ▓███████   ░▒▒░     ██▓█▓█▓█▓█████░                 
                   ▒█████▓█▓█▓██    ██████  ░████▒  ░ ░    ░█████   █████▒    ███▓█▓██████▒                   
                     ▒████▓█▓███░   ██████   ░▒▒░    ░░      ▓▓██   █████▓   ░██▓█▓█████▒                     
                       ▒█████████    ▒▓█▓       ░  ░░▒░         ▓   ░▓▓▓░    █████████▓                       
                         ▒████████░            ░▒░░▒░ ▒░▒░  ░░ ░           ▒████████▒                         
                           ░████████▓        ▒▒  ░▓░  ░ ▒█░ ░░░░░         ▓███████░                           
                             ▒██████▒░░░░  ░ ░░░░░   ░ ░   ░░░░░░░░░░░░░░░   ▒▓█▓                             
                              ░█▓     ░░   ░░                 ░░░░░░░░░░░░░                                   
                                  ░░░░░░░░░░░░░░              ░░░░░░ ░ ░ ██░░░                                
                                   ░▒░░░██▒ ▒█▓░░░▒         ░░░ ░█▒ ▓▒▓▒░▓█░                                  
                                     ░ ░██▒░░██░ ░░░░░  ░░▒▒░░░░░░░░░░░░░░                                    
                                           ░░▒░░░░▒▒░░░░░░░░░░░░░░░░                                          
                                                ░░░░░░░░░░░▒░▒▒                                                                                                                                                                                                                                                                                                  
*/    

#include "../Protocol/Protocol.h"
#include <iostream>
#include "MessageHandle.h"
#include "algorithm"
using namespace std;


uint8_t testBuffer[100];
void Device2GetData(FrameData fd);
void Device1GetData(FrameData fd);
void Device2GetError(ProtocolErrorCode err);
void Device1GetError(ProtocolErrorCode err);
uint8_t processStep = 0;
MessageHandle Device1(&Device1GetData, &Device1GetError), Device2(&Device2GetData, &Device2GetError);

void Device2GetData(FrameData fd){
    if(fd.protocolID == PROTOCOL_ID_HANDSHAKE){
        uint8_t *code = new (nothrow) uint8_t[fd.payloadLength]; 
        uint8_t *comparator = Device2.GetHandshakeCode();
        // bắt buộc phải memset 0, nếu không sẽ bị segmentation fault
        memset(code,0,fd.payloadLength);
        Device2.GetValueFromPayload((void*)code,fd.payloadLength);
        // Nếu bắt tay được thì 2 bên đang ở chế độ giải mã gói tin theo class Protocol
        if(memcmp(code,comparator,fd.payloadLength) == 0 && Device2.GetHandshakeStatus() == false) {
            std::cout << "Device2 matched handshake code, connection established, in protocol mode" << std::endl;
            Device2.SetHandshake(true);
            if(fd.requestData) {
                Device2.ResponseHandshake();
                std::cout << "Device2 response handshake code" << std::endl;
            }
            else std::cout << "Device2 connection established" << std::endl;
        }
        delete[] code;
        return;
    } 
    // Nếu không bắt tay được thì bỏ qua gói tin, không ở chế độ giải mã gói tin theo class Protocol
    else if (Device2.GetHandshakeStatus() == false) { 
        /* Nhận dữ liệu bình thường không thông qua xử lý khung truyền*/
        std::cout << "Device2 not in protocol mode, receive data" << std::endl;
        return;
    }
    std::cout << "Event: Device2 get message" << std::endl;
    uint8_t a = 0;
    float b = 0;
    TestDataStructure_t dataTest;
    if(fd.requestData != true){
        switch (fd.protocolID){
            case PROTOCOL_ID_1: // PROTOCOL_ID_1 quy định nhận số nguyên 8 bit không dấu
                Device2.GetValueFromPayload((void*)&a,sizeof(uint8_t));
                std::cout << "Device2 get value a is: "<< std::dec << (int)a << std::endl;
                break;
            case PROTOCOL_ID_2: // PROTOCOL_ID_2 quy định nhận số thực 32 bit 
                Device2.GetValueFromPayload((void*)&b,sizeof(float));
                std::cout << "Device2 get value b is: " << b << std::endl;
                break;
            case PROTOCOL_ID_3: // PROTOCOL_ID_3 quy định cấu trúc dữ liệu
                Device2.GetValueFromPayload((void*)&dataTest,sizeof(dataTest));
                std::cout << "Device2 get dataTest is: " << std::endl;
                std::cout << "\t" << "--> a: " << std::dec << (int)dataTest.a << std::endl;
                std::cout << "\t" << "--> b: " << dataTest.b << std::endl;
                std::cout << "\t" << "--> c: " << dataTest.c << std::endl;
                break;
            default:
                break;
        }
    }
    else {
        switch (fd.protocolID){
            case PROTOCOL_ID_1: // PROTOCOL_ID_1 quy định nhận số nguyên 8 bit không dấu
                a = 25;
                Device2.SendMessage((void*)&a,sizeof(uint8_t),(ProtocolListID)fd.protocolID);
                std::cout << "Device2 response value a" << std::endl;
                break;
            case PROTOCOL_ID_2: // PROTOCOL_ID_2 quy định nhận số thực 32 bit 
                b = -12.68;
                Device2.SendMessage((void*)&b,sizeof(float),(ProtocolListID)fd.protocolID);
                std::cout << "Device2 response value b" << std::endl;
                break;
            case PROTOCOL_ID_3: // PROTOCOL_ID_3 quy định cấu trúc dữ liệu
                dataTest.a = -34000;
                dataTest.b = -58.33;
                memset(dataTest.c,0,sizeof(dataTest.c));
                memcpy(dataTest.c,"SpiritBoi",strlen("SpiritBoi"));
                Device2.SendMessage((void*)&dataTest,sizeof(TestDataStructure_t),(ProtocolListID)fd.protocolID);
                std::cout << "Device2 response value dataTest "  << std::endl;
                break;
            default:
                break;
        }
    }
}

void Device1GetData(FrameData fd){
    if(fd.protocolID == PROTOCOL_ID_HANDSHAKE){
        uint8_t *code1 = new (nothrow) uint8_t[fd.payloadLength]; 
        uint8_t *comparator = Device1.GetHandshakeCode();
        // bắt buộc phải memset 0, nếu không sẽ bị segmentation fault
        memset(code1,0,fd.payloadLength);
        Device1.GetValueFromPayload((void*)code1,fd.payloadLength);
        // Nếu bắt tay được thì 2 bên đang ở chế độ giải mã gói tin theo class Protocol
        if(memcmp(code1,comparator,fd.payloadLength) == 0 && Device1.GetHandshakeStatus() == false) {
            std::cout << "Device1 matched handshake code, connection established, in protocol mode" << std::endl;
            Device1.SetHandshake(true);
            if(fd.requestData) {
                Device1.ResponseHandshake();
                std::cout << "Device1 response handshake code" << std::endl;
            }    
            else std::cout << "Device1 connection established" << std::endl;
        }
        delete[] code1;
        return;
    } 
    // Nếu không bắt tay được thì bỏ qua gói tin, không ở chế độ giải mã gói tin theo class Protocol
    else if (Device1.GetHandshakeStatus() == false) { 
        /* Nhận dữ liệu bình thường không thông qua xử lý khung truyền*/
        std::cout << "Device1 not in protocol mode, receive data" << std::endl;
        return;
    }
    std::cout << "Event: Device1 get message" << std::endl;
    uint8_t a = 0;
    float b = 0;
    TestDataStructure_t dataTest;
    if(fd.requestData != true){
        switch (fd.protocolID){
            case PROTOCOL_ID_1: // PROTOCOL_ID_1 quy định nhận số nguyên 8 bit không dấu
                Device1.GetValueFromPayload((void*)&a,sizeof(uint8_t));
                std::cout << "Device1 get value a is: "<< std::dec << (int)a << std::endl;
                break;
            case PROTOCOL_ID_2: // PROTOCOL_ID_2 quy định nhận số thực 32 bit 
                Device1.GetValueFromPayload((void*)&b,sizeof(float));
                std::cout << "Device1 get value b is: " << b << std::endl;
                break;
            case PROTOCOL_ID_3: // PROTOCOL_ID_3 quy định cấu trúc dữ liệu
                Device1.GetValueFromPayload((void*)&dataTest,sizeof(dataTest));
                std::cout << "Device1 get dataTest is: " << std::endl;
                std::cout << "\t" << "--> a: " << std::dec << (int)dataTest.a << std::endl;
                std::cout << "\t" << "--> b: " << dataTest.b << std::endl;
                std::cout << "\t" << "--> c: " << dataTest.c << std::endl;
                break;
            default:
                break;
        }
    }
    else {
        switch (fd.protocolID){
            case PROTOCOL_ID_1: // PROTOCOL_ID_1 quy định nhận số nguyên 8 bit không dấu
                a = 100;
                Device1.SendMessage((void*)&a,sizeof(uint8_t),(ProtocolListID)fd.protocolID);
                std::cout << "Device1 response value a" << std::endl;
                break;
            case PROTOCOL_ID_2: // PROTOCOL_ID_2 quy định nhận số thực 32 bit 
                b = 1240.18;
                Device1.SendMessage((void*)&b,sizeof(float),(ProtocolListID)fd.protocolID);
                std::cout << "Device1 response value b" << std::endl;
                break;
            case PROTOCOL_ID_3: // PROTOCOL_ID_3 quy định cấu trúc dữ liệu
                dataTest.a = 65535;
                dataTest.b = 10.41;
                memset(dataTest.c,0,sizeof(dataTest.c));
                memcpy(dataTest.c,"TM-Khoa",strlen("TM-Khoa"));
                Device1.SendMessage((void*)&dataTest,sizeof(dataTest),(ProtocolListID)fd.protocolID);
                std::cout << "Device1 response value dataTest "  << std::endl;
                break;
            default:
                break;
        }
    }
}





/**
 * @brief Giả lập ngoại vi của MCU gửi dữ liệu, ngoại vi mỗi lần chỉ copy một byte
 * dữ liệu từ RAM vào bộ đệm ngoại vi để gửi đi
 */
void SimulatePeripheralSendMessage(){
    static uint8_t i = 0;
    uint8_t periphBuffer[1] = {0};
    FrameData fd;
    MessageHandle *targetMesg = NULL;
    if(Device1.GetSendingStatus()){
        targetMesg = &Device1;
        cout << "Device1--->" << "\t";
    }
    else if(Device2.GetSendingStatus()){
        targetMesg = &Device2;
        cout << "Device2--->" << "\t";
    }
    else return;
    fd = targetMesg->GetFrameDataInfo();

    // Nếu frame data = 0 thì return
    if(fd.totalLength == 0) return;
    // Thực hiện copy 1 byte dữ liệu từ bộ đệm _txBuffer trong class Protocol vào bộ đệm ngoại vi
    memcpy(periphBuffer, targetMesg->GetAddressTxBuffer() + i, 1);
    // Gửi dữ liệu bộ đệm ngoại vi vào bộ đệm test để Device2 nhận
    memcpy(testBuffer + i, periphBuffer, 1);
    cout << "Sending byte: " << (int)i << " value: 0x" << std::hex << (int)*(targetMesg->GetAddressTxBuffer() + i)<< endl;
    i++;
    // Nếu đủ độ dài thì đã kết thúc frame truyền, thực hiện xóa bộ đệm _txBuffer
    if(i == fd.totalLength) {
        i = 0;
        targetMesg->ResetFrame();
        cout << "Sending complete" << endl;
    }
}

/**
 * @brief Giả lập ngoại vi của MCU nhận dữ liệu, ngoại vi mỗi lần chỉ copy một byte
 * dữ liệu từ bộ đệm ngoại vi vào RAM
 */
void SimulatePeripheralReceiveMessage(){
    static uint8_t i = 0;
    // Giả lập bộ đệm của ngoại vi MCU
    uint8_t periphBuffer[1] = {0};
    FrameData fd;
    MessageHandle *targetMesg = NULL;
    // Nếu bên gửi là device 1 thì bên nhận phải trỏ tới class của device 2
    if(Device1.GetSendingStatus()){
        targetMesg = &Device2;
        cout << "Device2--->"  << "\t";
    }
    else if(Device2.GetSendingStatus()){
        targetMesg = &Device1;
        cout << "Device1--->"  << "\t";
    }
    else return;
    fd = targetMesg->GetFrameDataInfo();
    if(testBuffer[0] == 0) return;
    if(fd.totalLength == 0) {
        memcpy(periphBuffer,testBuffer,1);
        fd.totalLength = testBuffer[0];
        // Set tổng độ dài frame truyền vào biến private FrameData trong class Protocol
        targetMesg->SetTotalLength(fd.totalLength);
        memcpy(targetMesg->GetAddressRxBuffer() + i, periphBuffer, 1);
        cout << "Receive byte: " << (int)i << " total length: " << std::dec << (int)fd.totalLength << endl;
        i++;
    } 
    else {
        memcpy(periphBuffer,testBuffer + i, 1);
        memcpy(targetMesg->GetAddressRxBuffer() + i, periphBuffer, 1);
        cout << "Receive byte: " << (int)i << " value: 0x" << std::hex << (int)*(targetMesg->GetAddressRxBuffer() + i) << endl;
        i++;
        // Nếu đủ độ dài thì đã kết thúc frame truyền, thực hiện xóa bộ đệm _txBuffer
        if(i == fd.totalLength) {
            cout << "Receive complete" << endl;
            // Xóa bộ đệm test sau khi nhận đầy đủ
            memset(testBuffer, 0, i);
            Device1.SetSendingStatus(false);
            Device2.SetSendingStatus(false);
            // Sau khi nhận đầy đủ khung truyền thì giải mã khung truyền, kiểm tra CRC16
            targetMesg->HandleReceiveMessage();
            i = 0;
            // Chỉ khi cả hai thiết lập kết nối thì mới bắt đầu thực hiện quá trình giao tiếp
            if(Device1.GetHandshakeStatus() == true && Device2.GetHandshakeStatus() == true){
                
                processStep++; // bắt đầu chuỗi giao tiếp mới

            }
        }
    }
}

void CommunicationProcess(){
    uint8_t a = 20;
    float b = 15.23;
    switch (processStep)
    {
    case 1: // Device 1 truyền số nguyên a
        cout << "********************CONNECTION ESTABLISHED*********************" << endl;
        cout << "**********************BEGIN COMMUNICATION***********************" << endl;
        Device1.SendMessage((void*)&a, sizeof(uint8_t), PROTOCOL_ID_1);
        cout << "Device 1 send a" << endl;
        processStep ++;
        break;
    case 2:
        // Không làm gì, nếu 2 device giao tiếp xong thì chuyển sang bước tiếp theo
        break;
    case 3: // Device 2 truyền số float b
        cout << "**********************NEXT TRANSFER***********************" << endl;
        Device2.SendMessage((void*)&b,sizeof(float),PROTOCOL_ID_2);
        cout << "Device 2 send b" << endl;
        processStep ++;
        break;
    case 4:
        // Không làm gì, nếu 2 device giao tiếp xong thì chuyển sang bước tiếp theo
        break;
    case 5:// Request dữ liệu từ device 2
        cout << "**********************NEXT TRANSFER***********************" << endl;
        Device1.SendMessage(PROTOCOL_ID_3,true);
        cout << "Device 1 request structure data" << endl;
        processStep ++;
        break;
    case 6:
        // Không làm gì, nếu 2 device giao tiếp xong thì chuyển sang bước tiếp theo
        break;
    default:
        break;
    }
}

int main(void){
    Device1.RequestHandshake();
    while(1) {
        CommunicationProcess();
        SimulatePeripheralSendMessage();
        SimulatePeripheralReceiveMessage();
    }
    return 0;
}

void Device2GetError(ProtocolErrorCode err){
    std::cout << "Event: Device2 error message event found:" << (int)err << std::endl;
    while(1);
}

void Device1GetError(ProtocolErrorCode err){
    std::cout << "Event: Device1 error message event found:" << (int)err << std::endl;
    while(1);
}